위상정렬을 알기전에 DAG 부터 알아야 한다.
여기서 DAG란 Directed acyclic Graph 로 비순환 방향 그래프를 의미한다.
위상 정렬은 비순환 방향 그래프에서 정점을 '선형'으로 정렬하는 것입니다.
그래프가 DAG가 아니라면 위상 정렬은 불가능합니다.
위살 정렬의 활용예로는 대학교 선수과목이 있다.
특정 과목을 수강하기위해서 그 선수 과목부터 수강 해야합니다.
여기서 위상 정렬은 특정 수강과목을 위해 필요한 선수과목의 정렬입니다.
예) C를 듣기위해 A를 들어야하고 B를 듣기위해 A를 들어야하고...
즉 선행 관계 구조 일때는 위상 정렬을 사용한다.

구현 방법은 in_degree를 사용하는 BFS 방법과 DFS 방법이있다.
BFS 는 순서를 저장할 리스트와 저장 여부를 알기위한 visited[N] 배열을 사용한다.
BFS 방법 (코드 예시 2252 번)
1. 모든 정점의 in_degree를 설정합니다.
2. in_degree가 0인 정점은 방문한 것으로 표시하고 큐에 정점을 추가합니다.
3. 큐가 빌 때까지 순회하며 다음 작업을 수행합니다.
3.1. 큐의 앞 요소를 dequeue()로 가져와 T[]에 append합니다.
3.2. dequeue()한 정점에 인접한 정점중 방문하지 않은 정점의 in_degree를 하나 감소시킵니다.
3.3. in_degree 감소 후 값이 0이면 해당 정점은 queue에 'enqueue()' 하고 방문한 것으로 표시합니다.


DFS 방법(in_degree 가 필요없고 재귀를 사용한다.)
1. 모든 정점을 순회하며 방문하지 않은 정점에 대해서 DFS를 수행합니다.
2. DFS 수행방식은 다음과 같습니다.
2.1. 하나의 정점에서 시작합니다.
2.2. 방문표시를 하면서 간선을 따라 다음 정점으로 방문합니다.
2.3. 더 이상 방문할 간선이 없으면 리스트 앞에 정점을 추가하고
        역추적(backtracking)을 통해 이전 정점으로 이동하면서 방문하지 않은 간선이 있는지 확인합니다.
2.4.방문 가능한 간선이 있다면 다시 간선을 따라 다음 정점으로 이동합니다.
2.5. 모든 정점을 탐색할 때까지 2.2~2.4를 반복합니다.
