ex) 백준 16958번
 플로이드 워셜 알고리즘에 대해서 간략하게 설명해보자면   하나의 맵에 존재하는 모든 정점간의 최단경로를 구하는데 주로 쓰이는 알고리즘이다.
 보통, 직접 연결할 때의 거리와, 특정 정점을 거쳐서 연결될 때의 거리를 비교해서 최단거리를 찾는 식으로 구현된다.
 초기적으로 이렇게 모든 거리를 구해서 MAP[][] 2차원배열에 저장해준다.

하지만 우리가 구한 값들은 최소값이 아니다. 직접적인 거리일 뿐이다. 
우리가 구해야 할 값들은 최소값이다. 즉, A에서 B로 움직인다고 가정했을 때, A -> C -> B가 최소가 된다고 가정해보자.
지금 우리가 저장해 놓은 값은, A -> B일때의 거리이지, 최소값이 아니라는 것이다. 이제 최소값을 찾기 위해서   플로이드 워셜 알고리즘이 사용되게 된다. 
플로이드 워셜 알고리즘은 보편적으로 3중 for문을 이용해서 구현하게 된다.
for (int k = 0; k < N; k++)    // 중간 점을 표시
{
  for (int i = 0; i < N; i++)    // 시작점을 표시    
  { 
    for (int j = 0; j < N; j++)    // 도착점을 표시        
    {
      if (i == j)continue; 
      if (MAP[i][j] > MAP[i][k] + MAP[k][j]) MAP[i][j] = MAP[i][k] + MAP[k][j];
      // 시작점 -> 도착점 보다, 시작점 -> 중간점 -> 도착점이 더 빠르다면 값을 갱신 !        
      }    
   } 
}
모든 정점사이의 최소거리 즉,
최솟값을 알수있게된다
